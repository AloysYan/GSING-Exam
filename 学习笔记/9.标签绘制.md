## 标注颜色标签代码详解

### 一、整体功能

在检测到的矩形左上角附近绘制颜色名称（如 "red"、"green"、"blue"、"yellow"），使用描边效果以提高可读性。

### 二、代码逐行解析

#### 第 75 行：转换数据类型

```py
        box_points = box.tolist()
```

- 作用：将 NumPy 数组转换为 Python 列表
- `box` 格式：NumPy 数组，形状 `(4, 2)`
- `box_points` 格式：Python 列表，例如：
```python
box_points = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]
```
- 原因：后续使用 Python 列表操作更方便

#### 第 76 行：找到最小 y 坐标（最上方的点）

```py
        min_y = min(pt[1] for pt in box_points)
```

- 作用：找到矩形 4 个顶点中 y 坐标最小的点（最上方）
- 语法：生成器表达式 `(pt[1] for pt in box_points)`
  - `pt`：每个顶点 `[x, y]`
  - `pt[1]`：y 坐标
  - `min(...)`：取最小值
- 结果：`min_y` 是最小的 y 值（最上方）

#### 第 77 行：找到最小 x 坐标（最左侧的点）

```py
        min_x = min(pt[0] for pt in box_points)
```

- 作用：找到矩形 4 个顶点中 x 坐标最小的点（最左侧）
- 语法：生成器表达式 `(pt[0] for pt in box_points)`
  - `pt[0]`：x 坐标
- 结果：`min_x` 是最小的 x 值（最左侧）

#### 第 78 行：计算文本 x 坐标（防止超出左边界）

```py
        text_x = max(5, min_x)
```

- 作用：确保文本不会太靠近图像左边缘
- 逻辑：
  - 如果 `min_x >= 5`：使用 `min_x`
  - 如果 `min_x < 5`：使用 `5`（留出左边距）
- 原因：避免文字被裁剪或显示不完整

#### 第 79 行：计算文本 y 坐标（在矩形上方）

```py
        text_y = max(15, min_y - 8)
```

- 作用：将文本放在矩形上方，并防止超出上边界
- 逻辑：
  - `min_y - 8`：在矩形最上方点上方 8 像素
  - `max(15, ...)`：确保 y 坐标至少为 15（留出上边距）
- 原因：文本在矩形上方，且不超出图像边界

#### 第 80 行：绘制白色描边（外层）

```py
        cv2.putText(image, cname, (text_x, text_y), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2, cv2.LINE_AA)
```

- 函数：`cv2.putText()` 绘制文字
- 参数：
  - `image`：目标图像
  - `cname`：文字内容（如 "red"、"green"）
  - `(text_x, text_y)`：文字左下角坐标
  - `cv2.FONT_HERSHEY_SIMPLEX`：字体
  - `0.6`：字体缩放
  - `(255, 255, 255)`：白色（BGR）
  - `2`：线宽（较粗，作为描边）
  - `cv2.LINE_AA`：抗锯齿
- 效果：绘制白色粗线文字（作为描边）

#### 第 81 行：绘制黑色主体（内层）

```py
        cv2.putText(image, cname, (text_x, text_y), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 1, cv2.LINE_AA)
```

- 参数：
  - `(0, 0, 0)`：黑色（BGR）
  - `1`：线宽（较细，作为主体）
- 效果：在白色描边上绘制黑色细线文字（主体）
- 结果：形成描边效果，提高可读性

### 三、描边效果原理

```
第80行：绘制白色粗线（线宽2）
    ╔═══════╗
    ║  red  ║  ← 白色描边
    ╚═══════╝

第81行：在相同位置绘制黑色细线（线宽1）
     red    ← 黑色主体

最终效果：
    ╔═══════╗
    ║  red  ║  ← 白色描边 + 黑色主体 = 描边文字
    ╚═══════╝
```

### 四、坐标计算可视化

假设矩形顶点为：
```
    P1(x1, y1) ────────── P2(x2, y2)
       │                        │
       │                        │
    P4(x4, y4) ────────── P3(x3, y3)
```

计算过程：
```python
min_x = min(x1, x2, x3, x4)  # 最左侧的 x
min_y = min(y1, y2, y3, y4)  # 最上方的 y

text_x = max(5, min_x)        # 确保不超出左边界
text_y = max(15, min_y - 8)   # 在矩形上方 8 像素
```

文字位置：
```
    "red"  ← 文字标签（在矩形左上角上方）
    ┌─────────────┐
    │             │
    │      ●      │  ← 矩形和中心点
    │             │
    └─────────────┘
```

### 五、`cv2.putText()` 函数详解

#### 函数签名
```python
cv2.putText(image, text, org, fontFace, fontScale, color, thickness, lineType)
```

#### 参数说明

| 参数 | 类型 | 说明 |
|------|------|------|
| `image` | `np.ndarray` | 目标图像（会被修改） |
| `text` | `str` | 要绘制的文字 |
| `org` | `tuple` | 文字左下角坐标 `(x, y)` |
| `fontFace` | `int` | 字体类型 |
| `fontScale` | `float` | 字体缩放因子 |
| `color` | `tuple` | 颜色 `(B, G, R)` |
| `thickness` | `int` | 线宽 |
| `lineType` | `int` | 线型（如 `cv2.LINE_AA` 抗锯齿） |

#### 常用字体类型
```python
cv2.FONT_HERSHEY_SIMPLEX      # 普通字体（代码中使用）
cv2.FONT_HERSHEY_PLAIN        # 小字体
cv2.FONT_HERSHEY_DUPLEX       # 复杂字体
cv2.FONT_HERSHEY_COMPLEX      # 复杂字体
cv2.FONT_HERSHEY_TRIPLEX      # 三线字体
cv2.FONT_HERSHEY_COMPLEX_SMALL # 小复杂字体
cv2.FONT_HERSHEY_SCRIPT_SIMPLEX # 手写体
cv2.FONT_HERSHEY_SCRIPT_COMPLEX # 复杂手写体
```

### 六、边界保护机制

#### 左边界保护
```python
text_x = max(5, min_x)
```
- 确保文字距离左边缘至少 5 像素

#### 上边界保护
```python
text_y = max(15, min_y - 8)
```
- 确保文字距离上边缘至少 15 像素
- `min_y - 8` 将文字放在矩形上方 8 像素

### 七、代码优化建议

当前实现使用两次 `cv2.putText()` 实现描边。也可以考虑：
1. 使用 `cv2.putText()` 的 `thickness` 参数
2. 使用图像处理技术（如膨胀）生成描边
3. 使用 PIL/Pillow 库的文字描边功能

### 八、实际效果

在检测到的方块上会显示：
```
    "red"  ← 白色描边 + 黑色主体的文字
    ┌─────────────┐
    │             │
    │      ●      │
    │             │
    └─────────────┘
```

### 总结

这段代码实现了：
1. 计算矩形左上角位置（第 75-77 行）
2. 计算安全的文字位置（第 78-79 行）
3. 绘制描边文字（第 80-81 行）

通过描边效果，确保文字在不同背景上都能清晰可见，提高可视化效果。