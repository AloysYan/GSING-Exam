# OpenCV-Python 基础语法大全

## 目录
- [安装与导入](#安装与导入)
- [图像基本操作](#图像基本操作)
- [图像处理](#图像处理)
- [绘图功能](#绘图功能)
- [视频处理](#视频处理)
- [特征检测与匹配](#特征检测与匹配)
- [图像分割](#图像分割)
- [实用工具](#实用工具)

## 安装与导入

### 安装OpenCV
```bash
pip install opencv-python
pip install opencv-contrib-python  # 包含额外模块
```

### 导入库
```python
import cv2
import numpy as np
import matplotlib.pyplot as plt
```

## 图像基本操作

### 读取图像
```python
# 读取图像
img = cv2.imread('image.jpg')

# 以不同模式读取
img_color = cv2.imread('image.jpg', cv2.IMREAD_COLOR)    # 彩色图像
img_grayscale = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)  # 灰度图像
img_unchanged = cv2.imread('image.jpg', cv2.IMREAD_UNCHANGED)  # 包含alpha通道
```

### 显示图像
```python
# 显示图像
cv2.imshow('Image Window', img)
cv2.waitKey(0)  # 等待按键，0表示无限等待
cv2.destroyAllWindows()  # 关闭所有窗口

# 使用matplotlib显示（需要BGR转RGB）
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.show()
```

### 保存图像
```python
# 保存图像
cv2.imwrite('output.jpg', img)

# 设置保存参数
cv2.imwrite('output.jpg', img, [cv2.IMWRITE_JPEG_QUALITY, 95])
cv2.imwrite('output.png', img, [cv2.IMWRITE_PNG_COMPRESSION, 9])
```

### 图像属性
```python
print("图像形状:", img.shape)      # (高度, 宽度, 通道数)
print("图像尺寸:", img.size)       # 总像素数
print("数据类型:", img.dtype)      # 数据类型
print("图像宽度:", img.shape[1])
print("图像高度:", img.shape[0])
print("通道数:", img.shape[2] if len(img.shape) == 3 else 1)
```

## 图像处理

### 颜色空间转换
```python
# BGR转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# BGR转HSV
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# BGR转RGB
rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 灰度转BGR
bgr_from_gray = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
```

### 图像几何变换
```python
# 调整大小
resized = cv2.resize(img, (new_width, new_height))
resized_scale = cv2.resize(img, None, fx=0.5, fy=0.5)  # 缩放50%

# 旋转
rows, cols = img.shape[:2]
M = cv2.getRotationMatrix2D((cols/2, rows/2), 45, 1)  # 中心点，角度，缩放
rotated = cv2.warpAffine(img, M, (cols, rows))

# 平移
M = np.float32([[1, 0, 100], [0, 1, 50]])  # x方向平移100，y方向平移50
translated = cv2.warpAffine(img, M, (cols, rows))

# 仿射变换
pts1 = np.float32([[50,50], [200,50], [50,200]])
pts2 = np.float32([[10,100], [200,50], [100,250]])
M = cv2.getAffineTransform(pts1, pts2)
affine = cv2.warpAffine(img, M, (cols, rows))

# 透视变换
pts1 = np.float32([[56,65], [368,52], [28,387], [389,390]])
pts2 = np.float32([[0,0], [300,0], [0,300], [300,300]])
M = cv2.getPerspectiveTransform(pts1, pts2)
perspective = cv2.warpPerspective(img, M, (300,300))
```

### 图像滤波
```python
# 均值滤波
blur = cv2.blur(img, (5,5))

# 高斯滤波
gaussian_blur = cv2.GaussianBlur(img, (5,5), 0)

# 中值滤波
median_blur = cv2.medianBlur(img, 5)

# 双边滤波（保边去噪）
bilateral = cv2.bilateralFilter(img, 9, 75, 75)
```

### 形态学操作
```python
# 创建核
kernel = np.ones((5,5), np.uint8)
kernel_ellipse = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
kernel_cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5))

# 腐蚀
erosion = cv2.erode(img, kernel, iterations=1)

# 膨胀
dilation = cv2.dilate(img, kernel, iterations=1)

# 开运算（先腐蚀后膨胀）
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

# 闭运算（先膨胀后腐蚀）
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)

# 形态学梯度
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)

# 顶帽
tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)

# 黑帽
blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)
```

### 图像阈值处理
```python
# 简单阈值
ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)
ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)
ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)
ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)

# 自适应阈值
thresh_adaptive = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, 
                                       cv2.THRESH_BINARY, 11, 2)
thresh_gaussian = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                       cv2.THRESH_BINARY, 11, 2)

# Otsu's二值化
ret, thresh_otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

## 绘图功能

### 基本绘图函数
```python
# 画线
cv2.line(img, (0,0), (511,511), (255,0,0), 5)  # 蓝色，5像素宽

# 画矩形
cv2.rectangle(img, (384,0), (510,128), (0,255,0), 3)  # 绿色，3像素宽
cv2.rectangle(img, (384,0), (510,128), (0,255,0), -1)  # 绿色，填充

# 画圆
cv2.circle(img, (447,63), 63, (0,0,255), -1)  # 红色，填充

# 画椭圆
cv2.ellipse(img, (256,256), (100,50), 0,0,360,255,-1)  # 完整椭圆

# 画多边形
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
pts = pts.reshape((-1,1,2))
cv2.polylines(img, [pts], True, (0,255,255))  # 黄色多边形

# 添加文字
font = cv2.FONT_HERSHEY_SIMPLEX
cv2.putText(img, 'OpenCV', (10,500), font, 4, (255,255,255), 2, cv2.LINE_AA)
```

### 绘制标记
```python
# 绘制标记点
cv2.drawMarker(img, (100,100), (0,0,255), cv2.MARKER_CROSS, 20, 2)
cv2.drawMarker(img, (200,200), (0,255,0), cv2.MARKER_STAR, 20, 2)

# 绘制箭头
cv2.arrowedLine(img, (50,50), (200,50), (255,0,0), 5)
```

## 视频处理

### 读取视频
```python
# 从文件读取视频
cap = cv2.VideoCapture('video.mp4')

# 从摄像头读取
cap = cv2.VideoCapture(0)  # 0表示默认摄像头

while cap.isOpened():
    ret, frame = cap.read()
    
    if ret:
        # 处理帧
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        cv2.imshow('Video', gray)
        
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
    else:
        break

cap.release()
cv2.destroyAllWindows()
```

### 视频属性
```python
# 获取视频属性
fps = cap.get(cv2.CAP_PROP_FPS)
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

# 设置视频属性
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
```

### 保存视频
```python
# 定义编解码器并创建VideoWriter对象
fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi', fourcc, 20.0, (640,480))

while cap.isOpened():
    ret, frame = cap.read()
    
    if ret:
        # 翻转帧
        frame = cv2.flip(frame, 0)
        
        # 写入帧
        out.write(frame)
        
        cv2.imshow('Recording', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    else:
        break

cap.release()
out.release()
cv2.destroyAllWindows()
```

## 特征检测与匹配

### 角点检测
```python
# Harris角点检测
gray = np.float32(gray)
dst = cv2.cornerHarris(gray, 2, 3, 0.04)
dst = cv2.dilate(dst, None)
img[dst > 0.01 * dst.max()] = [0,0,255]  # 标记角点为红色

# Shi-Tomasi角点检测
corners = cv2.goodFeaturesToTrack(gray, 25, 0.01, 10)
corners = np.int0(corners)

for i in corners:
    x,y = i.ravel()
    cv2.circle(img, (x,y), 3, 255, -1)
```

### SIFT特征
```python
# 初始化SIFT检测器
sift = cv2.SIFT_create()

# 检测关键点和描述符
keypoints, descriptors = sift.detectAndCompute(gray, None)

# 绘制关键点
img_sift = cv2.drawKeypoints(img, keypoints, None, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
```

### ORB特征
```python
# 初始化ORB检测器
orb = cv2.ORB_create()

# 检测关键点和描述符
keypoints, descriptors = orb.detectAndCompute(gray, None)

# 绘制关键点
img_orb = cv2.drawKeypoints(img, keypoints, None, color=(0,255,0), flags=0)
```

### 特征匹配
```python
# 创建匹配器
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

# 匹配特征
matches = bf.match(des1, des2)

# 按距离排序
matches = sorted(matches, key=lambda x: x.distance)

# 绘制匹配
img_matches = cv2.drawMatches(img1, kp1, img2, kp2, matches[:10], None, flags=2)
```

## 图像分割

### 边缘检测
```python
# Canny边缘检测
edges = cv2.Canny(gray, 100, 200)  # 最小阈值，最大阈值

# Laplacian边缘检测
laplacian = cv2.Laplacian(gray, cv2.CV_64F)

# Sobel边缘检测
sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=5)  # x方向
sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=5)  # y方向
```

### 轮廓检测
```python
# 查找轮廓
contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# 绘制所有轮廓
cv2.drawContours(img, contours, -1, (0,255,0), 3)

# 绘制单个轮廓
cv2.drawContours(img, contours, 3, (0,255,0), 3)

# 轮廓近似
epsilon = 0.1 * cv2.arcLength(contours[0], True)
approx = cv2.approxPolyDP(contours[0], epsilon, True)
```

### 轮廓特征
```python
# 轮廓面积
area = cv2.contourArea(cnt)

# 轮廓周长
perimeter = cv2.arcLength(cnt, True)

# 轮廓矩
M = cv2.moments(cnt)
cx = int(M['m10']/M['m00'])
cy = int(M['m01']/M['m00'])

# 轮廓边界
x,y,w,h = cv2.boundingRect(cnt)
aspect_ratio = float(w)/h

# 最小外接矩形
rect = cv2.minAreaRect(cnt)
box = cv2.boxPoints(rect)
box = np.int0(box)

# 最小外接圆
(x,y), radius = cv2.minEnclosingCircle(cnt)
center = (int(x), int(y))
radius = int(radius)

# 拟合椭圆
ellipse = cv2.fitEllipse(cnt)

# 拟合直线
rows, cols = img.shape[:2]
[vx,vy,x,y] = cv2.fitLine(cnt, cv2.DIST_L2, 0, 0.01, 0.01)
lefty = int((-x*vy/vx) + y)
righty = int(((cols-x)*vy/vx)+y)
```

## 实用工具

### 鼠标事件处理
```python
# 定义鼠标回调函数
def draw_circle(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDBLCLK:
        cv2.circle(img, (x,y), 100, (255,0,0), -1)

# 创建窗口并绑定回调函数
cv2.namedWindow('image')
cv2.setMouseCallback('image', draw_circle)

while True:
    cv2.imshow('image', img)
    if cv2.waitKey(20) & 0xFF == 27:  # 按ESC退出
        break

cv2.destroyAllWindows()
```

### 轨迹栏
```python
# 创建回调函数
def nothing(x):
    pass

# 创建窗口和轨迹栏
cv2.namedWindow('image')
cv2.createTrackbar('R', 'image', 0, 255, nothing)
cv2.createTrackbar('G', 'image', 0, 255, nothing)
cv2.createTrackbar('B', 'image', 0, 255, nothing)

while True:
    r = cv2.getTrackbarPos('R', 'image')
    g = cv2.getTrackbarPos('G', 'image')
    b = cv2.getTrackbarPos('B', 'image')
    
    img[:] = [b, g, r]
    cv2.imshow('image', img)
    
    if cv2.waitKey(1) & 0xFF == 27:
        break

cv2.destroyAllWindows()
```

### 图像金字塔
```python
# 高斯金字塔
lower = cv2.pyrDown(img)
higher = cv2.pyrUp(img)

# 拉普拉斯金字塔
```

### 直方图
```python
# 计算直方图
hist = cv2.calcHist([gray], [0], None, [256], [0,256])

# 直方图均衡化
equ = cv2.equalizeHist(gray)

# CLAHE（对比度受限的自适应直方图均衡化）
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
cl1 = clahe.apply(gray)
```

### 模板匹配
```python
# 模板匹配
result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

# 获取匹配位置
top_left = max_loc
bottom_right = (top_left[0] + w, top_left[1] + h)

# 绘制矩形框
cv2.rectangle(img, top_left, bottom_right, 255, 2)
```

---

这份OpenCV基础语法大全涵盖了图像处理的主要方面，建议结合实际项目进行练习。每个函数都有丰富的参数可以调整，通过实践可以更好地理解和掌握。